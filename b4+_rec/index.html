<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        
    let dict = ["ЛУЖА","ЛИПА","ЛОЖЬ","ЛУПА","ПАУТ","ПЛУТ","ЛОЖА","СЛОТ","ПАРА", "ЛОСЬ"];
    let beginWord = "ЛИСА";
    let endWord = "ЛОСЬ";

    function isDiffOne (word1, word2) {
    let diff = 0
    for (let i = 0; i < word1.length; i++) {
        if (word1[i] !== word2[i]) diff ++;
        };
    return diff;
    };

    let newArr = [];
    function nextStep (cw, wa, tw) {
        
        if (wa.length === 0) return null;
      outer:  for (let j = 0; j < wa.length; j++) {
            let w = wa[j];  
            
            if (isDiffOne(cw, w) === 1) {
                if (w === tw) {
                    break outer;
                  // и надо кактоперестать выполнять цикл дальше  
                }    
                
                let result = wa.filter(el => el !== w);
                newArr.push(w);   
                nextStep (w, result, tw);
               
            }
            // if (w === tw){
            //     return newArr;
            // } 
                
        }
            // return null;
            // return newArr;
            // newArr.unshift(cw);
            return newArr; // как сделать чтобы не возвращлся обратно к перебору массива???
            
        }
        // return null;
        
    
    

console.log(nextStep (beginWord, dict, endWord));



// dictFunc('ЛИCА','ЛОСЬ');
// // dictFunc('МУХА','СЛОН');
// // dictFunc('МУХА','ПЛОД');
// // dictFunc('МУХА','МУКА');

// function dictFunc(str1,str2){
//     var words=["ЛУЖА","ЛИРА","ЛИПА","ТАРА","ЛИГА","ЛОЖЬ","ЛУПА","ЛОЖА","СЛОТ","ПАРА"];
//     words.push(str2);
//     var used={};
//     console.log((f(str1,str2,words)).reduce(fra));
    
//     function fra(r,v,i,a) { 
//         return r+'-'+v; 
//     }

//     function f(str1,str2,words){
//         var wordsCount={};
//         used[str1]=true;
//         for ( var i=0; i<words.length; i++ ) {
//             var word=words[i];
//             var n=0;
//             for (var k=0;k<str1.length; k++) if (str1.charAt(k) !== word.charAt(k)) n++;
//             wordsCount[word]=n;
//         }
//         var wordsCountArr=[];
//         for ( word in wordsCount ) wordsCountArr.push( { word:word, count:wordsCount[word] } );
//         function compareFunc(a,b) { return a.count-b.count; }
//         wordsCountArr.sort(compareFunc);

//         for ( var z=0; z<words.length; z++ ) {
//             var wordCount=wordsCountArr[z];
//             words[z]=wordCount.word;
//         }
//         var result=words.shift();
//         while (str1!==str2) {
            // used[result]=true; 
            // return f(result,str2,words,used);
            //  }
//         return Object.keys(used);
//     }
    
// }





function getSameWords(word, dictionary) {
        let edge = [];
        for (let i = 0; i < dictionary.length; i++) {
            let count = 0;
            if (word === dictionary[i]) {
                continue;
            }
            for (let j = 0; j < dictionary[i].length; j++) {
                if (dictionary[i][j] === word[j]) {
                    count += 1;
                }
                if (count === 3) {
                    count = 0;
                    edge.push(dictionary[i]);
                }
            }
        }
        return edge;
    }

    function getSameWordsList(firstWord, secondWord) {
        let dictionary = [
            'ЛУЖА', 'МУЗА', 'ЛИРА', 'МЕХА', 'ЛИГА', 'ТАРА', 'ЛИПА', 'ТУРА',
            'ПАРК', 'ЛОЖЬ', 'ЛУПА', 'ПЛОТ', 'МУРА', 'ПАУК', 'ПАУТ', 'ПЛУТ',
            'ЛОЖА', 'СЛОТ', 'ПАРА'
        ];

        dictionary.unshift(firstWord);
        dictionary.push(secondWord);
        let list = {};
        for (let i = 0; i < dictionary.length; i++) {
            let word = dictionary[i];
            list[word] = getSameWords(word, dictionary);
        }
        return list;
    }

    function searchPath(firstWord, lastWord) {
        let list = getSameWordsList(firstWord, lastWord);
        let chainsList = [];

        function findChains(word, chain) {
            for (let i = 0; i < list[word].length; i++) {
                let nextWord = list[word][i];
                if (nextWord === lastWord) {
                    chainsList.push(chain.concat([word]).concat(nextWord));
                    return;
                }
                if (chain.includes(word)) {
                    continue;
                }
                findChains(nextWord, chain.concat([word]));
            }
        }

        findChains(firstWord, []);

        let shortestPath = chainsList.sort(function (a, b) {
            return a.length - b.length;
        });

        return shortestPath[0].join(' - ');
    }

    console.log(searchPath('ЛИСА', 'ЛОСЬ'));
    console.log(searchPath('МУХА', 'СЛОН'));






    </script>
</body>
</html>